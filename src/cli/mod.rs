use std::path::PathBuf;

use clap::{Args, Parser, Subcommand, ValueEnum};
use compact_genome::implementation::alphabets::dna_alphabet::DnaAlphabet;

use crate::error::{Error, Result};

#[derive(Parser)]
#[command(version)]
#[command(propagate_version = true)]
pub struct Cli {
    #[command(subcommand)]
    pub command: CliCommands,
}

#[derive(Subcommand)]
pub enum CliCommands {
    CreateNGramModel(CreateModelCommand),
    GeneratePair(GeneratePairCommand),
}

#[derive(Args)]
pub struct CreateModelCommand {
    /// The input fasta file that contains the sequences used to create the model.
    #[arg(short, long)]
    pub input_fasta: PathBuf,

    /// The alphabet expected in the input file.
    #[arg(short, long, default_value = "dna")]
    pub alphabet: CliAlphabet,

    /// The output file in which the model is stored.
    /// It will be overwritten if it already exists.
    #[arg(short, long)]
    pub output: PathBuf,

    /// Compute n-grams after removing all unknown characters.
    ///
    /// If this is not set, then unknown characters will result in an error.
    #[arg(short, long)]
    pub skip_unknown_characters: bool,

    /// Compute n-grams after capitalising all unknown characters.
    ///
    /// Capitalisation happens before skipping unknown characters.
    #[arg(short, long)]
    pub capitalise_characters: bool,

    /// The number of predecessor characters that determine the probability of the next character.
    ///
    /// Setting this to zero means that all characters are generated independently,
    /// setting it to one means that characters are generated with a probability depending on the previous one character, and so on.
    #[arg(short, long)]
    pub n_gram_context_length: usize,
}

#[derive(Args)]
pub struct GeneratePairCommand {
    /// The path to an n-gram model file that was generated by this tool.
    #[arg(short = 'm', long)]
    pub model: PathBuf,

    /// The path to the fasta output file to generate.
    /// It will be overwritten if it already exists.
    #[arg(short = 'o', long)]
    pub output: PathBuf,

    /// If set, the common ancestor will be stored in this fasta file.
    /// It will be overwritten if it already exists.
    #[arg(long)]
    pub ancestor_output: Option<PathBuf>,

    /// The length of the ancestor sequence to generate.
    #[arg(short = 'l', long)]
    pub ancestor_length: usize,

    /// The seed to use for the random generator.
    #[arg(long, default_value = "0")]
    pub random_seed: u64,

    /// The closeness of the reference to the common ancestor, between 0.0 and 1.0.
    ///
    /// A pair is generated by first generating a common ancestor, and then modifying it into both a reference and a query sequence.
    /// This value decides what fraction of all modifications are performed on the reference, and what on the query.
    /// The higher this value, the closer the reference is to the common ancestor, and hence the more modifications are performed on the query.
    ///
    /// If it is not possible to distribute the modifications between reference and query adhering this ratio,
    /// then a modification is randomly placed on either the reference or the query.
    ///
    /// **Examples:**
    /// If this value is 1.0, then all modifications are performed on the query.
    /// If this value is 0.0, then all modifications are performed on the reference.
    /// For the default value of 0.5, half the modifications are performed on the reference, and the other half are performed on the query.
    #[arg(long, default_value = "0.5")]
    pub reference_ancestry_fraction: f64,

    #[command(flatten)]
    pub sequence_modification_amount: SequenceModificationAmount,

    #[command(flatten)]
    pub sequence_modification_parameters: SequenceModificationParameters,
}

#[derive(Args, Clone, Copy)]
pub struct SequenceModificationAmount {
    /// The number of template switches to generate.
    #[arg(long, default_value = "1")]
    pub template_switch_amount: usize,

    /// The number of gaps to generate.
    #[arg(long, default_value = "10")]
    pub gap_amount: usize,

    /// The number of substitutions to generate.
    #[arg(long, default_value = "10")]
    pub substitution_amount: usize,
}

#[derive(Args, Clone, Copy)]
pub struct SequenceModificationParameters {
    /// If set, template switches are allowed to overlap.
    #[arg(long)]
    pub template_switch_overlap: bool,

    /// The maximum number of tries to create a non-overlapping template switch.
    /// If the maximum number of tries is reached and `--template-switch-overlap` is not set,
    /// then the generation aborts with an error.
    #[arg(long, default_value = "10000")]
    pub template_switch_maximum_overlap_tries: usize,

    /// The minimum length of a template switch.
    #[arg(long, default_value = "10")]
    pub template_switch_min_length: usize,

    /// The maximum length of a template switch.
    #[arg(long, default_value = "30")]
    pub template_switch_max_length: usize,

    /// The minimum offset of a template switch.
    #[arg(long, allow_negative_numbers = true, default_value = "-30")]
    pub template_switch_min_offset: isize,

    /// The maximum offset of a template switch.
    #[arg(long, allow_negative_numbers = true, default_value = "10")]
    pub template_switch_max_offset: isize,

    /// The minimum length difference of a template switch.
    #[arg(long, allow_negative_numbers = true, default_value = "-10")]
    pub template_switch_min_length_difference: isize,

    /// The maximum length difference of a template switch.
    #[arg(long, allow_negative_numbers = true, default_value = "10")]
    pub template_switch_max_length_difference: isize,

    /// The amount of characters at the beginning and end of a sequence that are not allowed to be part of a template switch.
    #[arg(long, default_value = "10")]
    pub template_switch_margin: usize,

    /// The parameter mean of the exponential distribution determining the gap length.
    /// Generated gaps always have a minimum length of one.
    #[arg(long, allow_negative_numbers = true, default_value = "3.0")]
    pub gap_length_mean: f64,
}

#[derive(ValueEnum, Clone, Copy)]
pub enum CliAlphabet {
    Dna,
}

pub trait IntoCliAlphabet {
    fn into_cli_alphabet() -> CliAlphabet;
}

impl IntoCliAlphabet for DnaAlphabet {
    fn into_cli_alphabet() -> CliAlphabet {
        CliAlphabet::Dna
    }
}

impl GeneratePairCommand {
    pub fn verify(&self) -> Result<()> {
        if self.reference_ancestry_fraction.is_nan() {
            return Err(Error::ReferenceAncestryFractionIsNaN);
        }
        if self.reference_ancestry_fraction < 0.0 || self.reference_ancestry_fraction > 1.0 {
            return Err(Error::ReferenceAncestryFractionOutOfRange(
                self.reference_ancestry_fraction,
            ));
        }

        if self
            .sequence_modification_parameters
            .gap_length_mean
            .is_nan()
        {
            return Err(Error::GapLengthMeanIsNaN);
        }
        if self.sequence_modification_parameters.gap_length_mean < 1.0
            || self.sequence_modification_parameters.gap_length_mean > self.ancestor_length as f64
        {
            return Err(Error::GapLengthMeanOutOfRange {
                actual: self.sequence_modification_parameters.gap_length_mean,
                minimum: 1.0,
                maximum: self.ancestor_length as f64,
            });
        }

        if self
            .sequence_modification_parameters
            .template_switch_min_offset
            > self
                .sequence_modification_parameters
                .template_switch_max_offset
        {
            return Err(Error::TemplateSwitchOffsetEmpty {
                min: self
                    .sequence_modification_parameters
                    .template_switch_min_offset,
                max: self
                    .sequence_modification_parameters
                    .template_switch_max_offset,
            });
        }
        if self
            .sequence_modification_parameters
            .template_switch_min_length
            > self
                .sequence_modification_parameters
                .template_switch_max_length
        {
            return Err(Error::TemplateSwitchLengthEmpty {
                min: self
                    .sequence_modification_parameters
                    .template_switch_min_length,
                max: self
                    .sequence_modification_parameters
                    .template_switch_max_length,
            });
        }
        if self
            .sequence_modification_parameters
            .template_switch_min_length_difference
            > self
                .sequence_modification_parameters
                .template_switch_max_length_difference
        {
            return Err(Error::TemplateSwitchLengthDifferenceEmpty {
                min: self
                    .sequence_modification_parameters
                    .template_switch_min_length_difference,
                max: self
                    .sequence_modification_parameters
                    .template_switch_max_length_difference,
            });
        }

        Ok(())
    }
}
