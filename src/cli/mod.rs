use std::path::PathBuf;

use clap::{Args, Parser, Subcommand, ValueEnum};
use compact_genome::implementation::alphabets::dna_alphabet::DnaAlphabet;

#[derive(Parser)]
#[command(version)]
#[command(propagate_version = true)]
pub struct Cli {
    #[command(subcommand)]
    pub command: CliCommands,
}

#[derive(Subcommand)]
pub enum CliCommands {
    CreateNGramModel(CreateModelCommand),
    GeneratePair(GeneratePairCommand),
}

#[derive(Args)]
pub struct CreateModelCommand {
    /// The input fasta file that contains the sequences used to create the model.
    #[arg(short, long)]
    pub input_fasta: PathBuf,

    /// The alphabet expected in the input file.
    #[arg(short, long, default_value = "dna")]
    pub alphabet: CliAlphabet,

    /// The output file in which the model is stored.
    /// It will be overwritten if it already exists.
    #[arg(short, long)]
    pub output: PathBuf,

    /// Compute n-grams after removing all unknown characters.
    ///
    /// If this is not set, then unknown characters will result in an error.
    #[arg(short, long)]
    pub skip_unknown_characters: bool,

    /// Compute n-grams after capitalising all unknown characters.
    ///
    /// Capitalisation happens before skipping unknown characters.
    #[arg(short, long)]
    pub capitalise_characters: bool,

    /// The number of predecessor characters that determine the probability of the next character.
    ///
    /// Setting this to zero means that all characters are generated independently,
    /// setting it to one means that characters are generated with a probability depending on the previous one character, and so on.
    #[arg(short, long)]
    pub n_gram_context_length: usize,
}

#[derive(Args)]
pub struct GeneratePairCommand {
    /// The path to an n-gram model file that was generated by this tool.
    #[arg(short = 'm', long)]
    pub model: PathBuf,

    /// The path to the fasta output file to generate.
    /// It will be overwritten if it already exists.
    #[arg(short = 'o', long)]
    pub output: PathBuf,

    /// If set, the common ancestor will be stored in this fasta file.
    /// It will be overwritten if it already exists.
    #[arg(long)]
    pub ancestor_output: Option<PathBuf>,

    /// The length of the ancestor sequence to generate.
    #[arg(short = 'l', long)]
    pub ancestor_length: usize,

    /// The closeness of the reference to the common ancestor, between 0.0 and 1.0.
    ///
    /// A pair is generated by first generating a common ancestor, and then modifying it into both a reference and a query sequence.
    /// This value decides what fraction of all modifications are performed on the reference, and what on the query.
    /// The higher this value, the closer the reference is to the common ancestor, and hence the more modifications are performed on the query.
    ///
    /// If it is not possible to distribute the modifications between reference and query adhering this ratio,
    /// then a modification is randomly placed on either the reference or the query.
    ///
    /// **Examples:**
    /// If this value is 1.0, then all modifications are performed on the query.
    /// If this value is 0.0, then all modifications are performed on the reference.
    /// For the default value of 0.5, half the modifications are performed on the reference, and the other half are performed on the query.
    #[arg(long, default_value = "0.5")]
    pub reference_ancestry_fraction: f64,

    /// The number of template switches to generate.
    #[arg(long)]
    pub template_switch_amount: usize,

    /// The minimum length of a template switch.
    #[arg(long)]
    pub template_switch_min_length: usize,

    /// The maximum length of a template switch.
    #[arg(long)]
    pub template_switch_max_length: usize,

    /// The minimum offset of a template switch.
    #[arg(long)]
    pub template_switch_min_offset: isize,

    /// The maximum offset of a template switch.
    #[arg(long)]
    pub template_switch_max_offset: isize,

    /// The minimum length difference of a template switch.
    #[arg(long)]
    pub template_switch_min_length_difference: isize,

    /// The maximum length difference of a template switch.
    #[arg(long)]
    pub template_switch_max_length_difference: isize,

    /// The number of gaps to generate.
    #[arg(long)]
    pub gap_amount: usize,

    /// The parameter mean of the exponential distribution determining the gap length.
    #[arg(long)]
    pub gap_length_mean: f64,

    /// The number of substitutions to generate.
    #[arg(long)]
    pub substitution_amount: usize,

    /// The seed to use for the random generator.
    #[arg(long)]
    pub random_seed: u64,
}

#[derive(ValueEnum, Clone, Copy)]
pub enum CliAlphabet {
    Dna,
}

pub trait IntoCliAlphabet {
    fn into_cli_alphabet() -> CliAlphabet;
}

impl IntoCliAlphabet for DnaAlphabet {
    fn into_cli_alphabet() -> CliAlphabet {
        CliAlphabet::Dna
    }
}
